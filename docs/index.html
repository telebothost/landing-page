<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>TBL Language Documentation</title>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css"/>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600&display=swap" rel="stylesheet"/>
  <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-2719295794573158" crossorigin="anonymous"></script>
  <!-- Highlight.js for syntax highlighting -->
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github.min.css">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
  <script>hljs.highlightAll();</script>
  <link rel="stylesheet" href="style.css">
</head>
<body>
  <header id="header">
    <div class="container nav-container">
      <a href="index.html" class="logo">
        <img src="/assets/img/logo.png" alt="TeleBot Host Logo">
        TeleBot Host
      </a>
      <nav class="nav-links">
        <a href="/" class="nav-link">Home</a>
      </nav>
    </div>
  </header>
  <section class="docs">
    <h2 class="section-title">TBL Language Reference</h2>
    <p class="section-subtitle">Full reference guide for TBL (Tele Bot Lang)</p>

    <div class="doc-content">

      <!-- 1. Introduction -->
      <h2 id="intro">Introduction</h2>
      <p><b>TBL (Tele Bot Lang)</b> is a lightweight scripting language designed specifically for Telegram bot development.  
      It provides a JavaScript-inspired syntax with built-in functions for rapid bot creation, without the overhead of external dependencies.</p>

      <h3>Key Features</h3>
      <ul>
        <li>Simplified command-based structure</li>
        <li>Predefined variables for user, chat, and message context</li>
        <li>Built-in API methods for sending messages, keyboards, and inline responses</li>
        <li>Support for HTTP requests, global variables, and modular extensions</li>
        <li>Support both synchronous and asynchronous execution, with 80% sync and 20% aync behaviour where <code>await</code>, <code>Promise</code> are valid</li>
      </ul>

      <div class="alert info">
        <i class="fas fa-info-circle"></i>
        <div>TBL scripts are <b>command-based</b>, meaning they respond to specific triggers instead of listening for events.</div>
      </div>

      <!-- 2. Getting Started -->
      <h2 id="getting-started">Getting Started</h2>
      <p>This section explains the basic steps to create and test your first Telegram bot using TBL.</p>

      <h3>Step 1: Create a Telegram Bot</h3>
      <ol>
        <li>Open Telegram and search for <a href="https://t.me/BotFather" target="_blank">@BotFather</a>.</li>
        <li>Send <code>/newbot</code> to create a new bot.</li>
        <li>Choose a name and a username (must end with <code>bot</code>).</li>
        <li>Copy the generated bot token.</li>
      </ol>

      <div class="code-container">
        <pre><code class="language-javascript">const botToken = "123456789:ABCdefGhIJKlmNoPQRsTUVwxyZ";</code></pre>
        <button class="copy-btn" onclick="copyCode(this)">Copy</button>
      </div>

      <h3>Step 2: Register on TBL Platform</h3>
      <ol>
        <li>Log into the TBL platform.</li>
        <li>Click "Create New Bot".</li>
        <li>Enter the bot name and paste the token from BotFather.</li>
        <li>Click "Create" to initialize your bot.</li>
      </ol>

      <h3>Step 3: Add Basic Commands</h3>
      <p>Create a <code>/start</code> command for user onboarding:</p>
      <div class="code-container">
        <pre><code class="language-javascript">Bot.sendMessage("Hello " + user.first_name + "! Welcome to my bot.")</code></pre>
        <button class="copy-btn" onclick="copyCode(this)">Copy</button>
      </div>

      <p>Example: <code>/help</code> command:</p>
      <div class="code-container">
        <pre><code class="language-javascript">
Bot.sendMessage("Available commands:\n/start - Start bot\n/help - Show help")</code></pre>
        <button class="copy-btn" onclick="copyCode(this)">Copy</button>
      </div>


 <!-- 3. Command Structure -->
<h2 id="commands">Command Structure</h2>
<p>Commands are the <b>core building blocks</b> of TBL. Instead of using event listeners like <code>bot.on()</code>, TBL follows a <b>command-driven model</b>.
  Each command acts like a rule: when the trigger matches, the bot runs its script.</p>

<h3 id="cmd-anatomy">Anatomy of a Command</h3>
<p>A command can include these parts:</p>
<ul>
  <li><b>Command Name</b> → the trigger (e.g. <code>/start</code>, <code>hi</code>, <code>/help</code>)</li>
  <li><b>Answer</b> → a quick static reply before running any code (supports Markdown)</li>
  <li><b>Code Block</b> → logic written in TBL’s JavaScript-like syntax</li>
  <li><b>Keyboard</b> → optional buttons for easy replies</li>
  <li><b>Aliases</b> → alternative triggers for the same command</li>
  <li><b>Need Reply</b> → makes the bot wait for the next user input</li>
</ul>

<h3 id="cmd-example">Example Command</h3>
<ul>
<li><b>command: </b><code>/start</code></li>
<li><b>answer: </b> <code>Welcome! Choose an option:</code></li>
<li><b>keyboard: </b><code>Help, About\nContact</code></li>
</ul>
<div class="code-container">
  <pre><code class="language-javascript">Bot.sendMessage("Hello " + user.first_name + "!")</code></pre>
  <button class="copy-btn" onclick="copyCode(this)">Copy</button>
</div>
<p>In this example:</p>
<ul>
  <li><b>Command</b>: <code>/start</code> triggers the command</li>
  <li><b>Answer</b>: bot instantly replies with "Welcome! Choose an option:"</li>
  <li><b>Keyboard</b>: provides 2 rows of buttons → [Help, About] and [Contact]</li>
  <li><b>Code</b>: sends a personalized message using the user’s first name</li>
</ul>

<h3 id="cmd-answer">Answer</h3>
<p>Answers are quick static messages. They appear <b>before</b> any code runs.</p>
<div class="code-container">
  <pre><code class="language-javascript">/*Command: /help
answer: I can do these things:
- /start → Start the bot
- /about → Info about me*/
Bot.sendMessage("Extra help details...")</code></pre>
  <button class="copy-btn" onclick="copyCode(this)">Copy</button>
</div>

<h3 id="cmd-needreply">Need Reply</h3>
<p>If <code>need_reply</code> is set to <code>true</code>, the bot waits for the next user message before continuing.</p>
<div class="code-container">
  <pre><code class="language-javascript">/*command: /ask
answer: What is your favorite color?
need_reply: true*/
Bot.sendMessage("You answered: " + message)</code></pre>
  <button class="copy-btn" onclick="copyCode(this)">Copy</button>
</div>

<h3 id="cmd-aliases">Aliases</h3>
<p>Aliases let one command have multiple triggers.</p>
<div class="code-container">
  <pre><code class="language-javascript">/*Command: /hello
aliases: hi, hey, hola*/
Bot.sendMessage("Hello there!")</code></pre>
  <button class="copy-btn" onclick="copyCode(this)">Copy</button>
</div>

<h3 id="cmd-keyboard">Keyboards</h3>
<p>Commands can show custom keyboards:</p>
<ul>
  <li><b>Same row</b>: use commas → <code>Yes,No</code></li>
  <li><b>New row</b>: use <code>\n</code> → <code>Yes\nNo</code></li>
</ul>
<div class="code-container">
  <pre><code class="language-javascript">/*Command: /menu
answer: Choose an option:
keyboard: Yes,No\nMaybe*/
Bot.sendMessage("Waiting for your choice...")</code></pre>
  <button class="copy-btn" onclick="copyCode(this)">Copy</button>
</div>

<h3 id="special-commands">Special Commands</h2>
<p>TBL provides special system-level commands:</p>
<ul>
  <li><b>@</b> → Initialization (runs before any others command execution)</li>
  <li><b>!</b> → Error handler (catches exceptions)</li>
  <li><b>@@</b> → Post-processing (runs after every command)</li>
  <li><b>*</b> → Wildcard (fallback when nothing else matches and master command that is able to handle all types of updates) [<a href="https://core.telegram.org/bots/api#update">Avilable Updates</a>]</li>
  <li><b>/inline_query</b> → Handles inline queries if not created inline Updates will listen by <code>*</code></li>
  <li><b>/channel_update</b> → Handles channel updates if not created inline Updates will listen by <code>*</code></li>
</ul>

<h3 id="cmd-init">@ Command (Initialization)</h3>
<p>Runs before executing any command, Useful for defining global variables or helper functions.</p>
<div class="code-container">
  <pre><code class="language-javascript">
Command: @
let config = { adminId: 123456 }
function formatName(u) {
  return u.first_name + (u.last_name ? " " + u.last_name : "")
}</code></pre>
  <button class="copy-btn" onclick="copyCode(this)">Copy</button>
</div>
      <div class="alert warning">
        <i class="fas fa-exclamation-triangle"></i>
        <div>@ command only support synchronous execution means no await here, however you can use an async function then use await in the async function </div>
      </div>

<h3 id="cmd-error">! Command (Error Handler)</h3>
<p>Handles all runtime errors automatically.</p>
<div class="code-container">
  <pre><code class="language-javascript">
Command: !
Bot.sendMessage("⚠️ An error occurred. Please try again.")
// in ! comamand we have error global variable to get details about error</code></pre>
  <button class="copy-btn" onclick="copyCode(this)">Copy</button>
</div>

<h3 id="cmd-wildcard">* Command (Wildcard)</h3>
<p>Fallback when no other command matches.</p>
<div class="code-container">
  <pre><code class="language-javascript">
Command: *
Bot.sendMessage("I didn’t understand that. Try /help.")</code></pre>
  <button class="copy-btn" onclick="copyCode(this)">Copy</button>
</div>

<h3 id="cmd-inline">/inline_query</h3>
<p>Handles inline mode queries (when users type <code>@yourbot query</code> in Telegram).</p>
<div class="code-container">
  <pre><code class="language-javascript">
Command: /inline_query
Bot.sendMessage("You searched: " + request.query)</code></pre>
  <button class="copy-btn" onclick="copyCode(this)">Copy</button>
</div>

<h3 id="cmd-channel">/channel_update</h3>
<p>Handles channel posts automatically.</p>
<div class="code-container">
  <pre><code class="language-javascript">Command: /channel_update
Bot.sendMessage("New channel post received!")</code></pre>
  <button class="copy-btn" onclick="copyCode(this)">Copy</button>
</div>

<h3 id="cmd-best">Best Practices</h2>
<ul>
  <li>Use <b>clear names</b> → <code>/buy_ticket</code>, not <code>/cmd69</code></li>
  <li>Use <b>aliases</b> for typos or multiple languages</li>
  <li>Always define <b>!</b> to avoid silent errors</li>
  <li>Keep commands <b>modular</b> (one task per command)</li>
  <li>Test async code carefully (especially with <code>await</code>)</li>
</ul>
      <div class="alert warning">
        <i class="fas fa-exclamation-triangle"></i>
        <div>Always define a <b>!</b> command to capture and handle runtime errors.</div>
      </div>


<!-- Global Predefined Values -->
<h2 id="globals">Global Predefined Values</h2>
<p>TBL provides a set of <b>predefined global variables</b>. These are available in every command, so you don’t need to declare them manually. They make it easier to work with Telegram updates, users, chats, and the bot itself.</p>

<h3 id="update">update</h3>
<p>The raw Telegram update object. Contains everything Telegram sends (messages, edits, queries, etc.).</p>
<div class="code-container">
<pre><code class="language-json">
{
  "update_id": 109608973,
  "message": {
    "message_id": 17261,
    "from": {
      "id": 5723455420,
      "is_bot": false,
      "first_name": "Soumyadeep ∞",
      "username": "soumyadeepdas765",
      "language_code": "en",
      "is_premium": true
    },
    "chat": {
      "id": 5723455420,
      "first_name": "Soumyadeep ∞",
      "username": "soumyadeepdas765",
      "type": "private"
    },
    "date": 1758100437,
    "text": "/start",
    "entities": [
      {
        "offset": 0,
        "length": 6,
        "type": "bot_command"
      }
    ]
  }
}
</code></pre>
  <button class="copy-btn" onclick="copyCode(this)">Copy</button>
</div>

<h3 id="request">request</h3>
<p>Simplified version of <code>update</code>. TBL automatically detects the type of update. like when the update type is <code>message</code> then request will be <code>update.message</code></p>

<h3 id="message">message</h3>
<p>Contains only the text of a message (if applicable).</p>
<div class="code-container">
  <pre><code class="language-json">"Hello bot"</code></pre>
  <button class="copy-btn" onclick="copyCode(this)">Copy</button>
</div>

<h3 id="user">user</h3>
<p>Information about the user interacting with the bot.</p>
<div class="code-container">
<pre><code class="language-json">
{
  "id": 5723455420,
  "is_bot": false,
  "first_name": "Soumyadeep ∞",
  "username": "soumyadeepdas765",
  "language_code": "en",
  "is_premium": true,
  "last_name": "",
  "telegramid": 5723455420,
  "premium": true,
  "created_at": "2025-09-17T09:13:57.880Z",
  "last_interaction": "2025-09-17T09:16:42.243Z",
  "just_created": false,
  "blocked": false,
  "block_reason": null,
  "blocked_at": null
}
</code></pre>
  <button class="copy-btn" onclick="copyCode(this)">Copy</button>
</div>

<h3 id="chat">chat</h3>
<p>Details about the current chat (private, group, or channel).</p>
<div class="code-container">
<pre><code class="language-json">
{
  "id": 5723455420,
  "first_name": "Soumyadeep ∞",
  "username": "soumyadeepdas765",
  "type": "private",
  "chatid": 5723455420,
  "chatId": 5723455420,
  "created_at": "2025-09-17T09:13:57.880Z",
  "last_interaction": "2025-09-17T09:18:20.486Z",
  "just_created": false,
  "blocked": false,
  "block_reason": null,
  "blocked_at": null
}
</code></pre>
  <button class="copy-btn" onclick="copyCode(this)">Copy</button>
</div>

<h3 id="bot">bot</h3>
<p>Information about the bot including owner, status, and platform info.</p>
<div class="code-container">
  <pre><code class="language-json">
{
  "id": 42, // bot id in our platform , a unique identifier for each bot
  "token": "123456:ABC...",
  "name": "DemoBot",
  "bot_id": 987654321, // Bot actual Telegram id
  "owner": "somemail@telebothost.com",//bot owner mail
  "status": "working",
  "created_at": "2025-01-01",
  "updated_at": "2025-01-10",
  "has_own_ip": true,
  "_securityNote": "All bot tokens are securely encrypted in storage and during transmission.",
  "_fairUseNote": "Usage must comply with policies. Harmful or unfair use may result in a ban."
}
  </code></pre>
  <button class="copy-btn" onclick="copyCode(this)">Copy</button>
</div>

<h3 id="params">params</h3>
<p>Extra text after a command. Example: "/start hello" → <code>params = "hello"</code>.</p>
<div class="code-container">
  <pre><code class="language-json">"hello"</code></pre>
  <button class="copy-btn" onclick="copyCode(this)">Copy</button>
</div>

<h3 id="options">options</h3>
<p>Custom data passed between commands when chaining or using API callbacks.</p>
<div class="code-container">
  <pre><code class="language-json">
//passing custom 
{
  "name": "Alice",
  "step": 2
}

//when callback of Telegram Api call 
{
  "ok": true,
  "result": {...}
}
  </code></pre>
  <button class="copy-btn" onclick="copyCode(this)">Copy</button>
</div>

<h3 id="content">content</h3>
<p>Contains the response body from an HTTP request. Auto type detection and parse inbuilt so you don't need <code>JSON.parse(content)</code> here, or if text you will get utf8 decoded value</p>

<h3 id="inspect">inspect()</h3>
<p>Helper function to print any object for debugging.</p>
<p>like if you did <code>inspect(data)</code> it will return bot <a href="#bot">Details</a></p>

<h3 id="msg">msg</h3>
<p><code>msg</code> is a simplified version of <code>update</code>. It’s only available for <code>message</code> updates.</p>
<p>Whenever a message update is received, <code>msg</code> will contain the same object as <code>update.message</code>.</p>

<h3 id="error"></h3>
<p>It's a object that gives information about error got by ! command</p>
<!-- Global Classes -->
<h2 id="classes">Global Classes</h2>
<p>
  TBL provides several predefined classes. These classes give you direct access
  to Telegram features, user data, and external utilities.
  The most important one is <code>Api</code>, which works as a direct wrapper
  for the official <a href="https://core.telegram.org/bots/api" target="_blank">Telegram Bot API</a>.
</p>

<h3 id="api-class">Api</h3>
<p>
  The <code>Api</code> class lets you call any method supported by Telegram.
  It is very flexible — you can use it directly, with command callbacks, or with async/await.
  This class is essential whenever you need full control over Telegram messages, files, and interactions.
</p>
      <div class="alert info">
        <i class="fas fa-info-circle"></i>
        <div>Api methods are case <b>insensitive</b> so you can use both <code>sendMessage</code> or <code>sendmessage</code> </div>
      </div>
<h4 id="api-normal">1. Normal Usage</h4>
<p>
  The simplest way to use <code>Api</code> is to call a method directly.  
  By default, if you don’t provide <code>chat_id</code>, it will automatically use the current chat.
</p>
<div class="code-container">
  <pre><code class="language-javascript">
// Send a message (chat_id is optional, defaults to current chat)
Api.sendMessage({
  text: "Hello " + msg.from.first_name
})

// Send a photo with caption
Api.sendPhoto({
  chat_id: msg.chat.id,
  photo: "https://example.com/cat.jpg",
  caption: "Here is a cat 🐱"
})
  </code></pre>
  <button class="copy-btn" onclick="copyCode(this)">Copy</button>
</div>

<h4 id="api-onrun">2. Usage with <code>on_run</code> Callback</h4>
<p>
  Every API call can be linked with another command using <code>on_run</code>.  
  After the API method finishes, its full result is automatically passed to the next command 
  as <code>options</code>. This allows you to work with Telegram’s response without writing extra logic.
</p>
<div class="code-container">
  <pre><code class="language-javascript">
// Call Api.getMe and continue in another command
Api.getMe({ on_run: "afterGetMe" })
/*
//you can pass tbl_options too like
Api.getMe({ on_run: "afterGetMe", tbl_options: {key: 111} })
//in afterGetMe tbl_options.key avilable 
*/
// Inside "afterGetMe" command:
if (options.ok) {
  Api.sendMessage({
    text: "Bot username: @" + options.result.username
  })
}
  </code></pre>
  <button class="copy-btn" onclick="copyCode(this)">Copy</button>
</div>
<p>
  This style is useful when you want to split logic across multiple commands, 
  especially for complex flows or long-running bots.
</p>

<h4 id="api-async">3. Usage with Async / Await</h4>
<p>
  You can also use <code>async/await</code> with any Api method.  
  The method returns a full Telegram response object, where <code>ok</code> indicates success 
  and <code>result</code> contains the actual data.
</p>
<div class="code-container">
  <pre><code class="language-javascript">
  let data = await Api.getMe()
  if (data.ok) {
    let me = data.result
    Api.sendMessage({
      text: "My bot id is " + me.id
    })
  }
  </code></pre>
  <button class="copy-btn" onclick="copyCode(this)">Copy</button>
</div>
<p>
  This approach is preferred when you want to stay inside a single command 
  and handle multiple API calls in sequence, keeping your code clean and readable.
</p>


<!-- Bot Class -->
<h2 id="bot-class">Bot Class</h2>
<p>
  The <b>Bot</b> class is used for controlling your bot directly.
  It provides methods for running commands, sending messages, and managing persistent bot-level properties.
  Unlike <code>Api</code>, the <code>Bot</code> methods are designed to be easier to use inside commands.
</p>

   <div class="alert info">
        <i class="fas fa-info-circle"></i>
        <div>Bot methods are case sensitive, so only strict name allowed like <b>sendMessage</b> abd <b>sendmessage</b> are treated as separate method</div>
      </div>


<h3 id="bot-run">1. Command Execution</h3>
<p>
  You can tell the bot to run another command. This is useful if you want to move the user to a new flow.
  These methods don’t return any value – they just execute.
</p>

<div class="code-container">
  <pre><code class="language-javascript">// Run another command
Bot.runCommand("/start")

// Run with options
Bot.runCommand("/start", {key: 111})
// key is avilable now in /start and accessable with options.key
</code></pre>
  <button class="copy-btn" onclick="copyCode(this)">Copy</button>
</div>

<p>
  Example: If the user types <code>/begin</code>, you can redirect them to <code>/start</code>:
</p>

<div class="code-container">
  <pre><code class="language-javascript">Bot.runCommand("/start")</code></pre>
  <button class="copy-btn" onclick="copyCode(this)">Copy</button>
</div>

<h3 id="bot-send">2. Sending Messages</h3>
<p>
  These methods send messages or media to the current chat.
  They return the <code>Telegram API response</code>.
  Using <code>await</code> is optional – you can wait for the result or just send without waiting.
</p>

<div class="code-container">
  <pre><code class="language-javascript">// Send plain text
Bot.sendMessage("Hello user!") 

// Send with HTML formatting
let res = await Bot.sendMessage("Hello <b>friend</b>", { parse_mode: "html" })
Bot.inspect(res) // See the Telegram response

// Send with a keyboard
Bot.sendKeyboard("Choose an option:", "Yes,No")

// Send files
Bot.sendDocument("file.pdf", { caption: "Here is your file" })
Bot.sendPhoto("photo.jpg", { caption: "Nice view!" })
Bot.sendAudio("music.mp3", { performer: "Artist", title: "Track" })
Bot.sendVideo("video.mp4", { caption: "Watch this" })
Bot.sendVoice("voice.ogg")

// Debugging an object
Bot.inspect({ user: "Alice", id: 123 })
</code></pre>
  <button class="copy-btn" onclick="copyCode(this)">Copy</button>
</div>

<p><b>Example output when sending a text message:</b></p>

<div class="code-container">
  <pre><code>{
  "ok": true,
  "result": {
    "message_id": 42,
    "chat": { "id": 5723455420, "type": "private" },
    "text": "Hello user!"
  }
}
</code></pre>
  <button class="copy-btn" onclick="copyCode(this)">Copy</button>
</div>

<h3 id="bot-props">3. Properties</h3>
<p>
  Bot properties are simple key-value storage.
  They let you save data that belongs to the bot itself (not a specific user).
  All property methods are synchronous, so <code>await</code> is not required.
</p>

<div class="code-container">
  <pre><code class="language-javascript">// Set properties

// set(key, value, type)
Bot.set("version", "1.2.3", "string")
Bot.set("config", { apiKey: "xyz" }, "json")

// Get values
let v = Bot.get("version")   // "1.2.3"
let c = Bot.get("config")    // { apiKey: "xyz" }

// Delete one property
Bot.del("version")

// Get all properties
let all = Bot.getAll()
// -> { config: { apiKey: "xyz" } }

// Delete all
Bot.delAll()

// Check if a property exists
let has = Bot.has("config")  // true

// Count all properties
let count = Bot.count()      // e.g. 1

// Get all property names
let names = Bot.getNames()   // ["config"]

/* 
//avilable data types
'string'    // String values
'number'    // Numeric values  
'boolean'   // Boolean values
'date'      // Date objects
'json'      // Objects/Arrays (stored as JSON)
'buffer'    // Buffer objects (binary data)
'set'       // Set objects
'list'      // Array objects
'map'       // Map objects
*/
</code></pre>
  <button class="copy-btn" onclick="copyCode(this)">Copy</button>
</div>
      <div class="alert info">
        <i class="fas fa-info-circle"></i>
        <div>type is optional on set methods if not provided will auto detects it's actual type</div>
      </div>

<p><b>Example workflow:</b></p>

<div class="code-container">
  <pre><code class="language-javascript">// Save a global config
Bot.set("welcome", "Hello new user!", "string")

// Later, use it in a message
let msg = Bot.get("welcome")
Bot.sendMessage(msg)

// Update a property
Bot.set("welcome", "Hi there 👋", "string")

// Remove a property
Bot.del("welcome")
</code></pre>
  <button class="copy-btn" onclick="copyCode(this)">Copy</button>
</div>

<h3 id="bot-prop-alias">4. Property Aliases</h3>
<p>
  All property methods have short aliases.
  They work exactly the same, just different names.
</p>

<div class="code-container">
  <pre><code class="language-javascript">// Setting values
Bot.setProp("theme", "dark", "string")
Bot.setProperty("lang", "en", "string")

// Getting values
Bot.getProp("theme")        // "dark"
Bot.getProperty("lang")     // "en"

// Deleting values
Bot.delProp("theme")
Bot.delProperty("lang")

// Get all / delete all
Bot.getAllProp()            // { }
Bot.getAllProperty()        // { }
Bot.delAllProp()
Bot.delAllProperty()

// Checking and counting
Bot.hasProp("theme")        // false
Bot.countProps()            // 0
Bot.getPropNames()          // []
</code></pre>
  <button class="copy-btn" onclick="copyCode(this)">Copy</button>
</div>

<!-- HTTP Class -->
<h2 id="http">HTTP Class</h2>
<p>
The <b>HTTP</b> class allows your bot to make external API requests (GET, POST, etc.) and handle responses flexibly.  
It supports direct calls with <code>await</code>, chaining commands via <code>on_run</code>, or using <code>tbl_options</code> for success/error handling.
</p>

<h3 id="http-get">1. GET Requests</h3>
<p>Simple GET request:</p>

<div class="code-container">
<pre><code class="language-js">
// GET request using direct URL
let data = await HTTP.get("https://jsonplaceholder.typicode.com/todos/1")
Bot.inspect(data)

// GET request using object with options
let data2 = await HTTP.get({
  url: "https://jsonplaceholder.typicode.com/todos/2",
  headers: { "Authorization": "Bearer ABC123" }
})
Bot.inspect(data2)
</code></pre>
<button class="copy-btn" onclick="copyCode(this)">Copy</button>
</div>

<h3 id="http-post">2. POST Requests</h3>
<p>POST request example:</p>

<div class="code-container">
<pre><code class="language-js">
// POST request
let payload = { name: "Alice", age: 25 }
let response = await HTTP.post({
  url: "https://jsonplaceholder.typicode.com/posts",
  body: payload,
  headers: { "Authorization": "Bearer ABC123" }
})
Bot.inspect(response)
</code></pre>
<button class="copy-btn" onclick="copyCode(this)">Copy</button>
</div>

<h3 id="http-tbl-options">3. Success / Error Commands with <code>tbl_options</code></h3>
<p>
You can define commands to run automatically on success or error.  
If <code>error</code> command is missing, the <code>success</code> command will run instead.
</p>

<div class="code-container">
<pre><code class="language-js">
// HTTP GET with success/error commands
HTTP.get({
  url: "https://jsonplaceholder.typicode.com/todos/1",
  tbl_options: {
    success: "onSuccess",
    error: "onError"
  }
})

// "onSuccess" command will receive options = HTTP response
// "onError" command will receive options = HTTP error
</code></pre>
<button class="copy-btn" onclick="copyCode(this)">Copy</button>
</div>

<div class="code-container">
<pre><code class="language-js">
// Example success command
/*command: onSuccess*/
Bot.sendMessage("Fetched title: " + options.result.title)

// Example error command
/*command: onError*/
Bot.sendMessage("HTTP request failed: " + options.status)
</code></pre>
<button class="copy-btn" onclick="copyCode(this)">Copy</button>
</div>

<h3 id="http-advanced">4. Advanced Options</h3>
<ul>
  <li><b>headers</b> – Custom headers</li>
  <li><b>body</b> – Object or data to send in POST requests</li>
  <li><b>query</b> – Object of query parameters for GET requests</li>
  <li><b>timeout</b> – Request timeout in milliseconds</li>
</ul>

<div class="code-container">
<pre><code class="language-js">
// GET with query params and headers, and success/error commands
HTTP.get({
  url: "https://api.example.com/search",
  query: { q: "telebot", limit: 5 },
  headers: { "X-Api-Key": "123ABC" },
  timeout: 5000,
  tbl_options: { success: "searchSuccess", error: "searchError" }
})
</code></pre>
<button class="copy-btn" onclick="copyCode(this)">Copy</button>
</div>

<h3 id="http-usage-notes">Usage Notes</h3>
<ul>
  <li>All HTTP methods return <code>result</code> object: <code>{ ok, status, result }</code>.</li>
  <li>You can use <code>await</code> to wait for the response or skip it if not needed.</li>
  <li><code>tbl_options</code> enables automatic command execution for success/error handling.</li>
  <li>If <code>error</code> command is missing, the <code>success</code> command will run instead.</li>
</ul>
<!-- content will stop here -->
    </div>
  </section>

<footer class="footer">
  <div class="footer-links">
    <a href="/privacy">Privacy</a>
    <a href="/terms">Terms</a>
    <a href="/cookies">Cookies</a>
    <a href="/resources">Resources</a>
  </div>
</footer>

<script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>
<script src="script.js" type="text/javascript" charset="utf-8"></script>
</body>
</html>

<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Anti AdBlock</title>
    <script async src="https://telebothost.com/f.js?client=ca-pub-2719295794573158" crossorigin="anonymous"></script>
</head>
<body>
<div id="adsbygoogl" style="padding:20px; background:#fafafa; border-radius:10px; margin:20px 0;">
  <h2 style="margin-bottom:10px;">Recommended Resources</h2>
  <p style="margin-bottom:15px;">
    Here are some helpful tools, guides, and updates curated just for you.  
    Explore the latest tutorials, tech news, and featured articles while supporting our website.
  </p>

  <!-- docad -->
  <ins class="adsbygoogle"
       style="display:block; margin:20px 0;"
       data-ad-client="ca-pub-2719295794573158"
       data-ad-slot="4335444793"
       data-ad-format="auto"
       data-full-width-responsive="true"></ins>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({});
  </script>

  <p style="margin-top:15px;">
    We keep updating this section regularly.  
    Stay tuned for more helpful content and recommendations!
  </p>
</div>
<script>
(function() {
  "use strict";
  
  const config = {
    // Multiple test URLs including fallbacks
    testUrls: [
      "https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js",
      "https://google-analytics.com/ga.js",
      "https://connect.facebook.net/en_US/fbevents.js"
    ],
    retries: 3,
    timeoutPerAttempt: 5000, // Increased for global users
    overlayId: "_adblock_overlay",
    message: "Please disable Ad Blocker to continue.",
    showBackground: true,
    enabled: true,
    checkInterval: 30000, // Less frequent checks
    initialDelay: 3000,
    // New: Additional detection methods
    testElements: [
      { id: 'TestAd', className: 'advertisement', tag: 'div' },
      { id: 'GoogleAdSense', className: 'adsbygoogle', tag: 'ins' }
    ]
  };
  
  const state = { 
    isPaused: false, 
    isChecking: false, 
    checkCount: 0,
    lastCheck: 0,
    userHasAdBlock: false
  };
  
  // Helper functions
  function $(selector) { 
    try { return document.querySelector(selector) } 
    catch (e) { return null } 
  }
  
  function getMaxZIndex() { 
    return Math.max(...Array.from(document.querySelectorAll("body *"), 
      e => parseInt(getComputedStyle(e).zIndex) || 0), 0) + 10; 
  }
  
  // METHOD 1: Script loading detection (original method)
  function testViaScript(url) {
    return new Promise((resolve) => {
      const script = document.createElement('script');
      script.src = url + '?cb=' + Date.now();
      script.async = true;
      
      const timeoutId = setTimeout(() => {
        script.onload = script.onerror = null;
        document.head.removeChild(script);
        resolve(false);
      }, config.timeoutPerAttempt);
      
      script.onload = () => {
        clearTimeout(timeoutId);
        script.onload = script.onerror = null;
        document.head.removeChild(script);
        resolve(true);
      };
      
      script.onerror = () => {
        clearTimeout(timeoutId);
        script.onload = script.onerror = null;
        document.head.removeChild(script);
        resolve(false);
      };
      
      document.head.appendChild(script);
    });
  }
  
  // METHOD 2: XHR detection (new method)
  function testViaXHR(url) {
    return new Promise((resolve) => {
      try {
        const xhr = new XMLHttpRequest();
        xhr.open('GET', url + '?cb=' + Date.now(), true);
        xhr.timeout = config.timeoutPerAttempt;
        
        xhr.onload = () => {
          // Check if response was actually blocked/modified
          const isBlocked = xhr.status === 0 || 
                          xhr.responseText.includes('adblock') ||
                          xhr.responseText.length < 100; // Generic check
          resolve(!isBlocked);
        };
        
        xhr.onerror = () => resolve(false);
        xhr.ontimeout = () => resolve(false);
        
        xhr.send();
      } catch (e) {
        resolve(false);
      }
    });
  }
  
  // METHOD 3: DOM element detection
  function testViaDOM() {
    return new Promise((resolve) => {
      try {
        // Create test ad elements
        const testElements = [];
        config.testElements.forEach(test => {
          const el = document.createElement(test.tag);
          el.id = test.id;
          el.className = test.className;
          el.style.cssText = 'position:absolute;left:-9999px;top:-9999px;width:1px;height:1px;opacity:0.001;';
          document.body.appendChild(el);
          testElements.push(el);
        });
        
        // Check if elements were modified/removed
        setTimeout(() => {
          let isBlocked = false;
          
          testElements.forEach(el => {
            const computedStyle = window.getComputedStyle(el);
            if (computedStyle.display === 'none' || 
                computedStyle.visibility === 'hidden' ||
                computedStyle.opacity === '0' ||
                !document.body.contains(el)) {
              isBlocked = true;
            }
            if (el.parentNode) {
              el.parentNode.removeChild(el);
            }
          });
          
          resolve(!isBlocked);
        }, 100);
      } catch (e) {
        resolve(true); // Don't penalize for DOM errors
      }
    });
  }
  
  // METHOD 4: Fetch API detection (as fallback)
  function testViaFetch(url) {
    return new Promise((resolve) => {
      if (typeof fetch !== 'function') {
        resolve(true); // Old browser, assume no adblock
        return;
      }
      
      const controller = new AbortController();
      const timeoutId = setTimeout(() => controller.abort(), config.timeoutPerAttempt);
      
      fetch(url + '?cb=' + Date.now(), { 
        method: 'HEAD',
        mode: 'no-cors',
        signal: controller.signal
      })
      .then(response => {
        clearTimeout(timeoutId);
        // In no-cors mode, we can't read status, but we can detect complete failure
        resolve(response.type !== 'opaque');
      })
      .catch(error => {
        clearTimeout(timeoutId);
        resolve(false);
      });
    });
  }
  
  // Comprehensive adblock detection
  async function detectAdBlock() {
    if (state.isChecking) return state.userHasAdBlock;
    state.isChecking = true;
    state.checkCount++;
    
    const results = [];
    const testUrl = config.testUrls[0]; // Primary test URL
    
    // Run all detection methods in parallel
    const detectionPromises = [
      testViaScript(testUrl),
      testViaXHR(testUrl),
      testViaDOM(),
      testViaFetch(testUrl)
    ];
    
    try {
      const methodResults = await Promise.allSettled(detectionPromises);
      
      // Analyze results
      methodResults.forEach((result, index) => {
        if (result.status === 'fulfilled') {
          results.push(result.value);
        } else {
          results.push(false); // Method failed, assume blocked
        }
      });
      
      // Require multiple methods to agree for reliability
      const blockedCount = results.filter(r => r === false).length;
      const totalMethods = results.length;
      
      // If majority of methods detect blocking, confirm adblock
      state.userHasAdBlock = blockedCount >= Math.ceil(totalMethods / 2);
      
    } catch (error) {
      console.warn('Adblock detection error:', error);
      state.userHasAdBlock = false; // Don't block on errors
    }
    
    state.isChecking = false;
    state.lastCheck = Date.now();
    return state.userHasAdBlock;
  }
  
  // Overlay functions (improved)
  function showOverlay() {
    if ($("#" + config.overlayId)) return;
    
    const overlay = document.createElement("div");
    overlay.id = config.overlayId;
    overlay.style.cssText = `
      position: fixed;
      inset: 0;
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      padding: 20px;
      box-sizing: border-box;
      background: ${config.showBackground ? 'rgba(0,0,0,0.95)' : '#000'};
      color: #fff;
      font-family: Arial, sans-serif;
      text-align: center;
      z-index: ${getMaxZIndex()};
      pointer-events: auto;
    `;
    
    const content = document.createElement("div");
    content.style.cssText = "max-width: 760px; padding: 40px; background: rgba(255,255,255,0.1); border-radius: 12px;";
    
    content.innerHTML = `
      <h2 style="margin: 0 0 20px 0; font-size: 24px; color: #fff;">${config.message}</h2>
      <p style="margin: 0 0 25px 0; font-size: 16px; opacity: 0.9; line-height: 1.5;">
        Our service relies on advertising to remain free.<br>
        Please consider whitelisting our site in your ad blocker or disabling it temporarily.
      </p>
      <div style="display: flex; gap: 15px; justify-content: center; flex-wrap: wrap;">
        <button id="retryBtn" style="padding: 12px 30px; font-size: 16px; cursor: pointer; border: none; border-radius: 6px; background: #4CAF50; color: white; font-weight: bold;">
          I've disabled Ad Blocker
        </button>
        <button id="skipBtn" style="padding: 12px 30px; font-size: 16px; cursor: pointer; border: 1px solid #666; border-radius: 6px; background: transparent; color: #ccc;">
          Continue Anyway (Limited)
        </button>
      </div>
      <p style="margin-top: 25px; font-size: 14px; opacity: 0.7;">
        If you're seeing this by mistake, your connection might be slow. Please wait a moment.
      </p>
    `;
    
    overlay.appendChild(content);
    document.body.appendChild(overlay);
    
    // Add event listeners
    document.getElementById('retryBtn').addEventListener('click', retryCheck);
    document.getElementById('skipBtn').addEventListener('click', () => {
      hideOverlay();
      state.isPaused = true;
      // Allow limited access for 1 hour
      setTimeout(() => { state.isPaused = false; }, 3600000);
    });
    
    // Prevent body scrolling
    document.documentElement.style.overflow = 'hidden';
    document.body.style.overflow = 'hidden';
  }
  
  function hideOverlay() {
    const overlay = $("##" + config.overlayId);
    if (overlay && overlay.parentNode) {
      overlay.parentNode.removeChild(overlay);
    }
    
    // Restore scrolling
    document.documentElement.style.overflow = '';
    document.body.style.overflow = '';
  }
  
  async function retryCheck() {
    state.isPaused = false;
    hideOverlay();
    
    // Add a small delay before retrying
    await new Promise(resolve => setTimeout(resolve, 1000));
    
    const hasAdBlock = await detectAdBlock();
    if (hasAdBlock) {
      showOverlay();
    }
  }
  
  // Main checking function
  async function performCheck() {
    if (state.isPaused || state.isChecking) return;
    
    // Don't check too frequently
    const timeSinceLastCheck = Date.now() - state.lastCheck;
    if (timeSinceLastCheck < 5000) return;
    
    const hasAdBlock = await detectAdBlock();
    
    if (hasAdBlock && !state.isPaused) {
      showOverlay();
    } else {
      hideOverlay();
    }
  }
  
  // Initialize
  if (config.enabled) {
    const init = () => {
      // Initial check after delay
      setTimeout(() => {
        performCheck();
        
        // Periodic checks (less frequent)
        setInterval(() => {
          if (!state.isPaused) {
            performCheck();
          }
        }, config.checkInterval);
      }, config.initialDelay);
    };
    
    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', init, { once: true });
    } else {
      init();
    }
    
    // Also check on page visibility change
    document.addEventListener('visibilitychange', () => {
      if (!document.hidden && !state.isPaused) {
        performCheck();
      }
    });
  }
})();
</script>

</body>
</html>